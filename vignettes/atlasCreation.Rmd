---
title: "atlasCreation.rmd"
author: "Sidhant Puntambekar"
date: "8/14/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Research Focus

Annotation of Single Cell RNA-sequencing experiments can be difficult given the lack of functional metadata and the various formats of presenting a processed counts matrix. The NCBI Gene Expression Omnibus (GEO) database currently contains the largest amount of publicly available scRNA-seq data for researchers. This vignette focuses on creation of a single cell atlas for a mouse organism with cell types originating from NCBI GEO records. The goal is to not only account for the maximum number of cell types possible from NCBI GEO but also to include different representations/treatments of the same cell. A single cell atlas for mice organisms would boost the efficacy of clustifyr since it would be able to give accurate benchmarks of cell types from any novel scRNA-seq experiment without proper metadata and cell type annotation. 

## Generating Reference Matrices

Individual reference matrices can be generated which show average gene expression values per individual cell type from a scRNA-seq experiment. In order to generate the reference matrices, the processed data from GEO such as the counts matrix and metadata table will be loaded in. The counts matrix will be checked for containing raw counts (counts matrix may have been previously log or scalar normalized). This is done with the help of a `check_raw_counts()` function. After the counts matrix is checked to contain raw counts, the data will be normalized with the help of the `NormalizeData()` function from Seurat. From there, the counts matrix and metadata table will be inputted as arguments into the clustifyr function `average_clusters()` which will output the reference matrix. The matrix can then be stored into an RDS file.

```{r Check Raw Counts}
checkRawCounts <- function(GSEMatrix, max_log_value = 50)
{
  if(!is.matrix(GSEMatrix))
  {
    GSEMatrix <- as.matrix(GSEMatrix)
  }
  if (is.integer(GSEMatrix))
  {
    return("raw counts")
  }
  else if (is.double(GSEMatrix))
  {
    if (all(GSEMatrix == floor(GSEMatrix)))
    {
      return("raw counts")
    }
    if(max(GSEMatrix) > max_log_value)
    {
      return("normalized")
    }
    else if (min(GSEMatrix) < 0)
    {
      stop("negative values detected, likely scaled data")
    }
    else
    {
      return("log-normalized")
    }
  }
  else
  {
    stop("unknown matrix format: ", typeof(GSEMatrix))
  }
}
```

```{r Reference Matrix Generation}
#An example of reference matrix generation for GEO record GSE124952
library(dplyr)
library(Seurat)
library(patchwork)
library(clustifyr)
library(tidyverse)
library(digest)
library(here)

mat_PFC <- read_csv("ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE124nnn/GSE124952/suppl/GSE124952_expression_matrix.csv.gz")
mat_PFC <- mat_PFC %>%
  column_to_rownames('X1')

meta_PFC <- read_csv("ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE124nnn/GSE124952/suppl/GSE124952_meta_data.csv.gz")
meta_PFC

# figure out project root
proj_dir <- here()
utils <- file.path(proj_dir, "Reference-Matrix-Generation", "R", "utils", "utils.r")

source(utils)
checkRawCounts(as.matrix(mat_PFC))

GSE124952Normalized <- NormalizeData(mat_PFC)
GSE124952Normalized

new_ref_matrix <- average_clusters(mat = GSE124952Normalized, metadata = meta_PFC$CellType, if_log = FALSE)
saveRDS(new_ref_matrix, "GSE124952.rds")
```

## Concatenating Reference Matrices into Cell Atlas

Once the individual reference matrices are generated, they can be concatenated into a single cell atlas encompassing all cells in an organism. In this case, all of the reference matrices are stored as RDS files in separate folder. In order to combine them, the union of all genes from a mice organism and genes present in the reference matrices will be applied. This will ensure that the reference matrices are all of the same row length which will make them easy to combine with a function such as `cbind()`. The union will be found with the `append_genes()` function and the atlas will be built with the `build_atlas()` function. 

```{r append_genes}
appendGenes <- function(geneVector, GSEMatrix)
{
  rownamesGSEMatrix <- rownames(GSEMatrix) #Get rownames from GSEMatrix (new GSE file)

  rowCountHumanGenes <- nrow(geneVector) #Calculate number of rows from list of full human genes
  rowCountNewGSEFile <- nrow(GSEMatrix) #Calculate number of rows of GSE matrix

  missing_rows <- setdiff(geneVector, rownamesGSEMatrix) #Use setdiff function to figure out rows which are different/missing from GSE matrix

  zeroExpressionMatrix <- matrix(0, nrow = length(missing_rows), ncol = ncol(GSEMatrix)) #Create a placeholder matrix with zeroes and missing_rows length as row length

  rownames(zeroExpressionMatrix) <- missing_rows #Assign row names
  colnames(zeroExpressionMatrix) <- colnames(GSEMatrix) #Assign column names

  fullMatrix <- rbind(GSEMatrix, zeroExpressionMatrix) #Bind GSEMatrix and zeroExpressionMatrix together

  #Reorder matrix
  fullMatrix <- fullMatrix[geneVector, ] #Reorder fullMatrix to preserve gene order
  return(fullMatrix) #Return fullMatrix
}
```

```{r build_atlas}
build_atlas <- function(matrix_fns,
                        genes_fn,
                        output_fn = NULL){

  genesVector <- read_lines(genes_fn)

  ref_mats <- lapply(matrix_fns, readRDS)

  if(is.null(names(matrix_fns))){
    names(ref_mats) <- basename(ref_matrices_fns) %>% str_remove(".rds$")
  } else {
    names(ref_mats) <- names(matrix_fns)
  }

  # iterate over list and get new matrices
  new_mats <- list()
  for(i in seq_along(ref_mats)){
    # standardize genes in matrix
    mat <- appendGenes(geneVector = genesVector,
                       GSEMatrix = as.matrix(ref_mats[[i]]))
    # get study name
    mat_name <- names(ref_mats)[i]

    # append study name to cell type names
    new_cols <- paste0(colnames(mat),
                       " (",
                       mat_name,
                       ")")
    colnames(mat) <- new_cols

    # assign to list
    new_mats[[i]] <- mat
  }

  # cbind a list of matrices
  atlas <- do.call(cbind, new_mats)

  if(!is.null(output_fn)){
    saveRDS(atlas, output_fn)
  } else {
    return(atlas)
  }

}

```

```{r Building atlas with reference matrices}
library(dplyr)
library(Seurat)
library(clustifyr)
library(tidyverse)
library(readr)
library(digest)
library(here)

# figure out project root
proj_dir <- here()

# get scripts
source(file.path(proj_dir, "Reference-Matrix-Generation", "R", "utils", "utils.r"))

# path to matrices
ref_matrix_dir <- file.path(proj_dir, "Reference-Matrix-Generation", "ref_matrices", "musMusculus")

# find all .rds files in the ref_matrices directory,
# name vector with file name without .rds
ref_matrices_fns <- list.files(ref_matrix_dir,
                               pattern = ".rds$",
                               full.names = TRUE,
                               recursive = TRUE)
names(ref_matrices_fns) <- basename(ref_matrices_fns) %>% str_remove(".rds$")

# remove studies in records_to_drop
records_to_drop <- c("GSE137710MouseSpleen")
idx_to_keep <- which(!names(ref_matrices_fns) %in% records_to_drop)
ref_matrices_fns <- ref_matrices_fns[idx_to_keep]

# path to mouse genes
mouse_genes_fn <- file.path(proj_dir, "Reference-Matrix-Generation",
                            "data",
                            "geneList",
                            "mouse_genes.tsv.gz")

# output file name for atlas
atlas_dir <- file.path(proj_dir, "atlas", "musMusculus")
dir.create(atlas_dir, showWarnings = FALSE, recursive = TRUE)
atlas_fn <- file.path(atlas_dir, "MouseAtlas.rds")

build_atlas(ref_matrices_fns, mouse_genes_fn, atlas_fn)
```

## Atlas Utility
The mouse cell atlas created using the GEO records and the Tabula Muris Cell atlas totaled 321 cell types. The inferences using clustifyr were observed to assign general cell types for major cell groups. However, more specific annotations were not possible due to the relatively small amount of cell types available. Next steps for the atlas would be to integrate a larger quantity of cell types but also different representations of the same cell types. This would allow the atlas to work correctly for benchmarking any new scRNA-seq data. 